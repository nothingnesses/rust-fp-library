//! Implementation of the `def_kind!` macro.
//!
//! This module handles the generation of a new Kind trait based on a signature.

use crate::{generate::generate_name, parse::KindInput};
use proc_macro2::TokenStream;
use quote::quote;
use syn::GenericParam;

/// Generates the implementation for the `def_kind!` macro.
///
/// This function takes the parsed input and generates a trait definition
/// for a Higher-Kinded Type signature with multiple associated types.
pub fn def_kind_impl(input: KindInput) -> TokenStream {
	let name = generate_name(&input);

	let assoc_types_tokens = input.assoc_types.iter().map(|assoc| {
		let ident = &assoc.ident;
		let generics = &assoc.generics;
		let output_bounds = &assoc.output_bounds;
		let output_bounds_tokens =
			if output_bounds.is_empty() { quote!() } else { quote!(: #output_bounds) };

		quote! {
			type #ident #generics #output_bounds_tokens;
		}
	});

	// Build summary for the first line
	let assoc_types_summary = input
		.assoc_types
		.iter()
		.map(|assoc| {
			let ident = &assoc.ident;
			let generics = &assoc.generics;
			let output_bounds = &assoc.output_bounds;
			let output_bounds_tokens =
				if output_bounds.is_empty() { quote!() } else { quote!(: #output_bounds) };

			let s = quote!(#ident #generics #output_bounds_tokens).to_string();
			// Clean up quote! output to match requested format
			let cleaned =
				s.replace(" < ", "<").replace(" >", ">").replace(" , ", ", ").replace(" : ", ": ");
			format!("`{}`", cleaned)
		})
		.collect::<Vec<_>>()
		.join("; ");

	// Build comprehensive documentation
	let assoc_types_doc = input
		.assoc_types
		.iter()
		.map(|assoc| {
			let ident = &assoc.ident;

			let mut l_count = 0;
			let mut t_count = 0;
			let mut params_doc = Vec::new();

			for param in &assoc.generics.params {
				match param {
					GenericParam::Lifetime(lt) => {
						l_count += 1;
						params_doc.push(format!("`{}`", lt.lifetime));
					}
					GenericParam::Type(ty) => {
						t_count += 1;
						let bounds_str = if ty.bounds.is_empty() {
							String::new()
						} else {
							format!(": {}", quote!(#ty.bounds))
						};
						params_doc.push(format!("`{}{}`", ty.ident, bounds_str));
					}
					_ => {}
				}
			}

			let output_bounds = &assoc.output_bounds;
			let output_bounds_doc = if output_bounds.is_empty() {
				"None".to_string()
			} else {
				format!("`{}`", quote!(#output_bounds))
			};

			format!(
				"### `type {}`\n\n\
			* **Lifetimes** ({}): {}\n\
			* **Type parameters** ({}): {}\n\
			* **Output bounds**: {}",
				ident,
				l_count,
				if l_count == 0 {
					"None".to_string()
				} else {
					params_doc
						.iter()
						.filter(|s| s.contains('\''))
						.cloned()
						.collect::<Vec<_>>()
						.join(", ")
				},
				t_count,
				if t_count == 0 {
					"None".to_string()
				} else {
					params_doc
						.iter()
						.filter(|s| !s.contains('\''))
						.cloned()
						.collect::<Vec<_>>()
						.join(", ")
				},
				output_bounds_doc
			)
		})
		.collect::<Vec<_>>()
		.join("\n\n");

	let doc_string = format!(
		r#"Kind with associated types: {}

Higher-Kinded Type (HKT) trait generated by `def_kind!`.

This trait was auto-generated and represents type constructors that can be applied
to generic parameters to produce concrete types.

# Associated Types

{}

# Implementation

To implement this trait for your type constructor, use the `impl_kind!` macro:

```ignore
impl_kind! {{
    for YourBrand {{
        type Of<...> = ...;
        type SendOf<...> = ...;
    }}
}}
```

# Naming

The trait name `{}` is a deterministic hash of the canonical signature,
ensuring that semantically equivalent signatures always map to the same trait.

# See Also

* [`Kind!`](crate::Kind!) - Macro to generate the name of a Kind trait
* [`impl_kind!`](crate::impl_kind!) - Macro to implement a Kind trait for a brand
* [`Apply!`](crate::Apply!) - Macro to apply a Kind to generic arguments"#,
		assoc_types_summary, assoc_types_doc, name
	);

	quote! {
		#[doc = #doc_string]
		#[allow(non_camel_case_types)]
		pub trait #name {
			#(#assoc_types_tokens)*
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	/// Helper function to parse a KindInput from a string.
	fn parse_kind_input(input: &str) -> KindInput {
		syn::parse_str(input).expect("Failed to parse KindInput")
	}

	// ===========================================================================
	// def_kind! Tests
	// ===========================================================================

	/// Tests def_kind! with a single associated type.
	#[test]
	fn test_def_kind_simple() {
		let input = parse_kind_input("type Of<A>;");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("type Of < A > ;"));
	}

	/// Tests def_kind! with multiple associated types.
	#[test]
	fn test_def_kind_multiple() {
		let input = parse_kind_input(
			"
			type Of<'a, T>: Display;
			type SendOf<U>: Send;
		",
		);
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("type Of < 'a , T > : Display ;"));
		assert!(output_str.contains("type SendOf < U > : Send ;"));
	}

	/// Tests def_kind! with complex bounds.
	#[test]
	fn test_def_kind_complex() {
		let input = parse_kind_input("type Of<'a, T: 'a + Clone>: Debug + Display;");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("type Of < 'a , T : 'a + Clone > : Debug + Display ;"));
	}
}
