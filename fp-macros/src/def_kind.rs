//! Implementation of the `def_kind!` macro.
//!
//! This module handles the generation of a new Kind trait based on a signature.

use crate::{generate::generate_name, parse::KindInput};
use proc_macro2::TokenStream;
use quote::quote;

/// Generates the implementation for the `def_kind!` macro.
///
/// This function takes the parsed input and generates a trait definition
/// for a Higher-Kinded Type signature.
pub fn def_kind_impl(input: KindInput) -> TokenStream {
	let name = generate_name(&input);

	let lifetimes = &input.lifetimes;

	let types_with_bounds = input.types.iter().map(|t| {
		let ident = &t.ident;
		let bounds = &t.bounds;
		if bounds.is_empty() {
			quote! { #ident }
		} else {
			quote! { #ident: #bounds }
		}
	});

	let output_bounds = &input.output_bounds;
	let output_bounds_tokens =
		if output_bounds.is_empty() { quote!() } else { quote!(: #output_bounds) };

	// Build comprehensive documentation
	let lifetime_count = input.lifetimes.len();
	let type_count = input.types.len();

	let lifetimes_doc = if lifetime_count == 0 {
		"None".to_string()
	} else {
		input.lifetimes.iter().map(|lt| format!("`{}`", lt)).collect::<Vec<_>>().join(", ")
	};

	let types_doc = if type_count == 0 {
		"None".to_string()
	} else {
		input
			.types
			.iter()
			.enumerate()
			.map(|(i, t)| {
				let bounds_str = if t.bounds.is_empty() {
					String::new()
				} else {
					format!(
						" (bounded by: {})",
						t.bounds
							.iter()
							.map(|b| format!("`{}`", quote!(#b)))
							.collect::<Vec<_>>()
							.join(" + ")
					)
				};
				format!("\n  * {}: `{}`{}", i, t.ident, bounds_str)
			})
			.collect::<String>()
	};

	let output_bounds_doc = if input.output_bounds.is_empty() {
		"None".to_string()
	} else {
		input
			.output_bounds
			.iter()
			.map(|b| format!("`{}`", quote!(#b)))
			.collect::<Vec<_>>()
			.join(" + ")
	};

	let doc_string = format!(
		r#"Higher-Kinded Type (HKT) trait with signature `({lifetimes_count} lifetime(s), {types_count} type(s))`.

This trait was auto-generated by the `def_kind!` macro and represents type constructors
that can be applied to the specified generic parameters to produce a concrete type.

# Signature

* **Lifetimes** ({lifetimes_count}): {lifetimes_list}
* **Type parameters** ({types_count}): {types_list}
* **Output bounds**: {output_bounds_list}

# Associated Type

This trait defines a single associated type `Of` that, when provided with the generic
parameters specified above, produces the concrete "applied" type.

# Implementation

To implement this trait for your type constructor, use the `impl_kind!` macro:

```ignore
impl_kind! {{
    for YourBrand {{
        type Of<{example_generics}>: {example_bounds} = YourType<{example_args}>;
    }}
}}
```

Where `YourBrand` is a zero-sized marker type representing your type constructor,
and `YourType` is the actual generic type being abstracted.

# Naming

The trait name `{trait_name}` is a deterministic hash of the canonical signature,
ensuring that semantically equivalent signatures always map to the same trait.

# See Also

* [`Kind!`](crate::Kind!) - Macro to generate the name of a Kind trait
* [`impl_kind!`](crate::impl_kind!) - Macro to implement a Kind trait for a brand
* [`Apply!`](crate::Apply!) - Macro to apply a brand to type arguments"#,
		lifetimes_count = lifetime_count,
		types_count = type_count,
		lifetimes_list = lifetimes_doc,
		types_list = types_doc,
		output_bounds_list = output_bounds_doc,
		example_generics = if lifetime_count == 0 && type_count == 0 {
			"/* generics */".to_string()
		} else {
			let lts = input.lifetimes.iter().map(|lt| quote!(#lt).to_string()).collect::<Vec<_>>();
			let tys = input
				.types
				.iter()
				.map(|t| {
					let ident = &t.ident;
					let bounds = &t.bounds;
					if bounds.is_empty() {
						quote!(#ident).to_string()
					} else {
						quote!(#ident: #bounds).to_string()
					}
				})
				.collect::<Vec<_>>();
			[lts, tys].concat().join(", ")
		},
		example_bounds = if input.output_bounds.is_empty() {
			"/* bounds */".to_string()
		} else {
			input
				.output_bounds
				.iter()
				.map(|b| quote!(#b).to_string())
				.collect::<Vec<_>>()
				.join(" + ")
		},
		example_args = if lifetime_count == 0 && type_count == 0 {
			"/* args */".to_string()
		} else {
			let lts = input.lifetimes.iter().map(|lt| quote!(#lt).to_string()).collect::<Vec<_>>();
			let tys = input
				.types
				.iter()
				.map(|t| {
					let ident = &t.ident;
					quote!(#ident).to_string()
				})
				.collect::<Vec<_>>();
			[lts, tys].concat().join(", ")
		},
		trait_name = name,
	);

	let generics_inner = if input.lifetimes.is_empty() {
		quote! { #(#types_with_bounds),* }
	} else if input.types.is_empty() {
		quote! { #lifetimes }
	} else {
		quote! { #lifetimes, #(#types_with_bounds),* }
	};

	quote! {
		#[doc = #doc_string]
		#[allow(non_camel_case_types)]
		pub trait #name {
			type Of < #generics_inner > #output_bounds_tokens;
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	/// Helper function to parse a KindInput from a string.
	fn parse_kind_input(input: &str) -> KindInput {
		syn::parse_str(input).expect("Failed to parse KindInput")
	}

	// ===========================================================================
	// def_kind! Tests
	// ===========================================================================

	/// Tests def_kind! with a single type parameter.
	///
	/// Verifies that the generated trait has the correct structure with
	/// a single unbounded type parameter.
	#[test]
	fn test_def_kind_simple_type() {
		let input = parse_kind_input("(), (A), ()");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		// Should generate a trait with Kind_ prefix
		assert!(output_str.contains("pub trait Kind_"));
		// Should have associated type Of with single type parameter
		assert!(output_str.contains("type Of < A >"));
	}

	/// Tests def_kind! with a lifetime and a type bounded by that lifetime.
	///
	/// Verifies that lifetime bounds on type parameters are correctly emitted.
	#[test]
	fn test_def_kind_with_lifetime() {
		let input = parse_kind_input("('a), (A: 'a), ()");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		// Should have both lifetime and bounded type parameter
		assert!(output_str.contains("'a"));
		assert!(output_str.contains("A : 'a"));
	}

	/// Tests def_kind! with bounds on the output type.
	///
	/// Verifies that output bounds (bounds on the associated type itself)
	/// are correctly emitted after a colon.
	#[test]
	fn test_def_kind_with_output_bounds() {
		let input = parse_kind_input("(), (A), (Clone)");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		// Should have output bounds
		assert!(output_str.contains(": Clone"));
	}

	/// Tests def_kind! with multiple output bounds.
	///
	/// Verifies that multiple bounds on the associated type are correctly
	/// joined with `+`.
	#[test]
	fn test_def_kind_with_multiple_output_bounds() {
		let input = parse_kind_input("(), (A), (Clone + Send)");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("Clone"));
		assert!(output_str.contains("Send"));
	}

	/// Tests def_kind! with bounds on a type parameter.
	///
	/// Verifies that bounds on type parameters (not output bounds) are
	/// correctly emitted after the type name.
	#[test]
	fn test_def_kind_with_type_bounds() {
		let input = parse_kind_input("(), (A: Clone + Send), ()");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("A : Clone + Send"));
	}

	/// Tests def_kind! with only lifetimes (no type parameters).
	///
	/// Verifies that the macro handles lifetime-only signatures correctly.
	#[test]
	fn test_def_kind_only_lifetimes() {
		let input = parse_kind_input("('a, 'b), (), ()");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("'a"));
		assert!(output_str.contains("'b"));
	}

	/// Tests def_kind! with multiple type parameters.
	///
	/// Verifies that multiple type parameters are correctly comma-separated.
	#[test]
	fn test_def_kind_multiple_types() {
		let input = parse_kind_input("(), (A, B, C), ()");
		let output = def_kind_impl(input);
		let output_str = output.to_string();

		assert!(output_str.contains("pub trait Kind_"));
		assert!(output_str.contains("type Of < A , B , C >"));
	}
}
