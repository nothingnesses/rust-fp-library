//! Implementation of the `def_kind!` macro.
//!
//! This module handles the generation of a new Kind trait based on a signature.

use crate::{generate::generate_name, parse::KindInput};
use proc_macro2::TokenStream;
use quote::quote;

/// Generates the implementation for the `def_kind!` macro.
///
/// This function takes the parsed input and generates a trait definition
/// for a Higher-Kinded Type signature.
pub fn def_kind_impl(input: KindInput) -> TokenStream {
	let name = generate_name(&input);

	let lifetimes = &input.lifetimes;

	let types_with_bounds = input.types.iter().map(|t| {
		let ident = &t.ident;
		let bounds = &t.bounds;
		if bounds.is_empty() {
			quote! { #ident }
		} else {
			quote! { #ident: #bounds }
		}
	});

	let output_bounds = &input.output_bounds;
	let output_bounds_tokens =
		if output_bounds.is_empty() { quote!() } else { quote!(: #output_bounds) };

	// Build comprehensive documentation
	let lifetime_count = input.lifetimes.len();
	let type_count = input.types.len();

	let lifetimes_doc = if lifetime_count == 0 {
		"None".to_string()
	} else {
		input.lifetimes.iter().map(|lt| format!("`{}`", lt)).collect::<Vec<_>>().join(", ")
	};

	let types_doc = if type_count == 0 {
		"None".to_string()
	} else {
		input
			.types
			.iter()
			.enumerate()
			.map(|(i, t)| {
				let bounds_str = if t.bounds.is_empty() {
					String::new()
				} else {
					format!(
						" (bounded by: {})",
						t.bounds
							.iter()
							.map(|b| format!("`{}`", quote!(#b)))
							.collect::<Vec<_>>()
							.join(" + ")
					)
				};
				format!("\n  * {}: `{}`{}", i, t.ident, bounds_str)
			})
			.collect::<String>()
	};

	let output_bounds_doc = if input.output_bounds.is_empty() {
		"None".to_string()
	} else {
		input
			.output_bounds
			.iter()
			.map(|b| format!("`{}`", quote!(#b)))
			.collect::<Vec<_>>()
			.join(" + ")
	};

	let doc_string = format!(
		r#"Higher-Kinded Type (HKT) trait with signature `({lifetimes_count} lifetime(s), {types_count} type(s))`.

This trait was auto-generated by the `def_kind!` macro and represents type constructors
that can be applied to the specified generic parameters to produce a concrete type.

# Signature

* **Lifetimes** ({lifetimes_count}): {lifetimes_list}
* **Type parameters** ({types_count}): {types_list}
* **Output bounds**: {output_bounds_list}

# Associated Type

This trait defines a single associated type `Of` that, when provided with the generic
parameters specified above, produces the concrete "applied" type.

# Implementation

To implement this trait for your type constructor, use the `impl_kind!` macro:

```ignore
impl_kind! {{
    for YourBrand {{
        type Of<{example_generics}>: {example_bounds} = YourType<{example_args}>;
    }}
}}
```

Where `YourBrand` is a zero-sized marker type representing your type constructor,
and `YourType` is the actual generic type being abstracted.

# Naming

The trait name `{trait_name}` is a deterministic hash of the canonical signature,
ensuring that semantically equivalent signatures always map to the same trait.

# See Also

* [`Kind!`](crate::Kind!) - Macro to generate the name of a Kind trait
* [`impl_kind!`](crate::impl_kind!) - Macro to implement a Kind trait for a brand
* [`Apply!`](crate::Apply!) - Macro to apply a brand to type arguments"#,
		lifetimes_count = lifetime_count,
		types_count = type_count,
		lifetimes_list = lifetimes_doc,
		types_list = types_doc,
		output_bounds_list = output_bounds_doc,
		example_generics = if lifetime_count == 0 && type_count == 0 {
			"/* generics */".to_string()
		} else {
			let lts = input.lifetimes.iter().map(|lt| quote!(#lt).to_string()).collect::<Vec<_>>();
			let tys = input
				.types
				.iter()
				.map(|t| {
					let ident = &t.ident;
					let bounds = &t.bounds;
					if bounds.is_empty() {
						quote!(#ident).to_string()
					} else {
						quote!(#ident: #bounds).to_string()
					}
				})
				.collect::<Vec<_>>();
			[lts, tys].concat().join(", ")
		},
		example_bounds = if input.output_bounds.is_empty() {
			"/* bounds */".to_string()
		} else {
			input
				.output_bounds
				.iter()
				.map(|b| quote!(#b).to_string())
				.collect::<Vec<_>>()
				.join(" + ")
		},
		example_args = if lifetime_count == 0 && type_count == 0 {
			"/* args */".to_string()
		} else {
			let lts = input.lifetimes.iter().map(|lt| quote!(#lt).to_string()).collect::<Vec<_>>();
			let tys = input
				.types
				.iter()
				.map(|t| {
					let ident = &t.ident;
					quote!(#ident).to_string()
				})
				.collect::<Vec<_>>();
			[lts, tys].concat().join(", ")
		},
		trait_name = name,
	);

	let generics_inner = if input.lifetimes.is_empty() {
		quote! { #(#types_with_bounds),* }
	} else if input.types.is_empty() {
		quote! { #lifetimes }
	} else {
		quote! { #lifetimes, #(#types_with_bounds),* }
	};

	quote! {
		#[doc = #doc_string]
		#[allow(non_camel_case_types)]
		pub trait #name {
			type Of < #generics_inner > #output_bounds_tokens;
		}
	}
}
